/*
 * Auto-generate image maps for inline and background images.
 * React Native requires static requires; so we emit a TS file with static require entries.
 */

const fs = require('fs');
const path = require('path');

const ROOT = path.resolve(__dirname, '..');
const ASSETS_DIR = path.join(ROOT, 'assets', 'images');
const INLINE_DIR = path.join(ASSETS_DIR, 'inline');
const BG_DIR = path.join(ASSETS_DIR, 'bg');
const OUTPUT_DIR = path.join(ROOT, 'constants', 'generated');
const OUTPUT_FILE = path.join(OUTPUT_DIR, 'imageMaps.ts');

const SUPPORTED_EXTENSIONS = ['.webp', '.png', '.jpg', '.jpeg'];

function stripScaleSuffix(baseName) {
  // remove @2x, @3x, @4x, @1.5x etc
  return baseName.replace(/@\d+(?:\.\d+)?x$/, '');
}

function parseScale(baseName) {
  const m = baseName.match(/@(\d+(?:\.\d+)?)x$/);
  if (!m) return 1;
  return parseFloat(m[1]);
}

function ensureDir(dir) {
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir, { recursive: true });
  }
}

function readImages(dir) {
  if (!fs.existsSync(dir)) return [];
  const files = fs.readdirSync(dir, { withFileTypes: true });
  return files
    .filter(f => f.isFile())
    .map(f => f.name)
    .filter(name =>
      SUPPORTED_EXTENSIONS.includes(path.extname(name).toLowerCase())
    );
}

function toMapEntries(dirFromGenerated, fileNames) {
  // group by normalized base (without @Nx)
  const groups = new Map();
  for (const name of fileNames) {
    const ext = path.extname(name).toLowerCase();
    const baseRaw = path.basename(name, ext);
    const norm = stripScaleSuffix(baseRaw);
    const arr = groups.get(norm) || [];
    arr.push({ name, ext, baseRaw });
    groups.set(norm, arr);
  }

  const entries = [];
  for (const [normBase, variants] of groups.entries()) {
    // split to base (no scale) and scaled
    const baseCandidates = variants.filter(v => v.baseRaw === normBase);
    const scaledCandidates = variants.filter(v => v.baseRaw !== normBase);

    let chosen = null;
    // prefer base file; among them prefer webp
    if (baseCandidates.length > 0) {
      baseCandidates.sort((a, b) => {
        const aw = a.ext === '.webp' ? 0 : 1;
        const bw = b.ext === '.webp' ? 0 : 1;
        return aw - bw;
      });
      chosen = baseCandidates[0];
    } else if (scaledCandidates.length > 0) {
      // choose smallest scale; among equals prefer webp
      scaledCandidates.sort((a, b) => {
        const sa = parseScale(a.baseRaw);
        const sb = parseScale(b.baseRaw);
        if (sa !== sb) return sa - sb;
        const aw = a.ext === '.webp' ? 0 : 1;
        const bw = b.ext === '.webp' ? 0 : 1;
        return aw - bw;
      });
      chosen = scaledCandidates[0];
    }

    if (chosen) {
      const rel = `${dirFromGenerated}/${chosen.name}`.replace(/\\/g, '/');
      entries.push({ key: normBase, relPath: rel });
    }
  }

  entries.sort((a, b) => a.key.localeCompare(b.key));
  return entries;
}

function generate() {
  const inlineFiles = readImages(INLINE_DIR);
  const bgFiles = readImages(BG_DIR);

  const inlineEntries = toMapEntries('../../assets/images/inline', inlineFiles);
  const bgEntries = toMapEntries('../../assets/images/bg', bgFiles);

  const header = `/**
 * This file is auto-generated by scripts/generateImageMap.js
 * DO NOT EDIT MANUALLY.
 */\n\nimport { ImageSourcePropType } from 'react-native';\n`;

  const inlineMap = `export const INLINE_IMAGE_MAP: Record<string, ImageSourcePropType> = {\n${inlineEntries
    .map(e => `  ${JSON.stringify(e.key)}: require('${e.relPath}'),`)
    .join('\n')}\n};\n`;

  const bgMap = `export const BACKGROUND_IMAGE_MAP: Record<string, ImageSourcePropType> = {\n${bgEntries
    .map(e => `  ${JSON.stringify(e.key)}: require('${e.relPath}'),`)
    .join('\n')}\n};\n`;

  const content = `${header}\n${inlineMap}\n${bgMap}`;

  ensureDir(OUTPUT_DIR);
  fs.writeFileSync(OUTPUT_FILE, content, 'utf8');
  console.log(`Generated ${path.relative(ROOT, OUTPUT_FILE)} with`);
  console.log(` - inline: ${inlineEntries.length} item(s)`);
  console.log(` - background: ${bgEntries.length} item(s)`);
}

generate();
